<h5>{{name}}</h5>
<div [ngSwitch]="name">
    <ng-container *ngSwitchCase="'selectionMode'">
        <p>
            This string option allows you to select whether to enable selection and, if so, what type. Default is <code>none</code>.
            The values currently supported for this option are listed{{forComponent ? "" : " below for each type of component"}}:
        </p>
        <ng-container *ngTemplateOutlet="helpRenderer;context:{tpl: selectionModeTpl, types: [componentType.list, componentType.table]}"></ng-container>
        <ng-template #selectionModeTpl let-type=type>
            <ul>
                <li>
                    <nui-expander [open]="false" header="none">
                        <p>Table rows are not selectable.</p>
                    </nui-expander>
                </li>
                <li>
                    <nui-expander [open]="false" header="multi">
                        <p>This option enables the possibility to select one or more rows in the {{forComponent ? forComponent : "component"}}.</p>
                        <ng-container *ngIf="type == componentType.table">
                            <p>To give users the ability to select rows, do the following:</p>
                            <ol>
                                <li>
                                    Set the <code>selectable</code> input to <code>true</code>.
                                </li>
                                <li>
                                    Bind a trackBy handler to the
                                    <code><a href="https://material.angular.io/cdk/table/overview#connecting-the-table-to-a-data-source" target="_blank">trackBy</a></code>
                                    property inherited from
                                    <code><a href="https://material.angular.io/cdk/table/overview" target="_blank">CdkTable</a></code>.
                                    The trackBy handler should return a value that uniquely identifies each item in the table.
                                    <br>
                                    <strong>Note:</strong> When <code>trackBy</code> is used, the
                                    <code><a href="../interfaces/ISelection.html" target="_blank">ISelection</a></code> will consist
                                    of the <code>trackBy</code> property values only and will not contain entire representations of the selected
                                    objects. As a result, it may be beneficial to keep a separate index that maps the selected item IDs
                                    to the corresponding objects.
                                </li>
                                <li>
                                    Pass the row object to <code>nui-row</code> using the <code>rowObject</code> input.
                                </li>
                                <li>
                                    Bind to the selection event using the <code>(selectionChange)</code> output. The event's payload is an
                                    <code><a href="../interfaces/ISelection.html" target="_blank">ISelection</a></code>
                                    object which should be converted to selected items by calling the <code>getSelectedItems</code>
                                    function on the
                                    <code><a href="../injectables/SelectorService.html" target="_blank">SelectorService</a></code>.
                                </li>
                            </ol>
                            <p>
                                <b>Note 1:</b>To preselect rows in a table or to programmatically change the selection you can use the
                                <code>selection</code> input which is of type
                                <code><a href="../interfaces/ISelection.html" target="_blank">ISelection</a></code>.
                            </p>
                            <p>
                                <b>Note 2:</b> If you need to use <code>nui-paginator</code> with row selection, you need to pass the total number
                                of items on all pages into the <code>totalItems</code> input.
                            </p>
                            <nui-message [allowDismiss]=false type="warning">
                                <p>
                                    <strong>Important:</strong> When working with data that's coming across the wire, it's necessary
                                    to bind a <code>trackBy</code> handler as mentioned above. This will allow selection tracking to be based on
                                    the identifier returned by the <code>trackBy</code> handler. If a <code>trackBy</code> is not provided, comparisons to
                                    determine whether items are selected will be based on object reference which of course
                                    won't work with items coming from a backend.
                                </p>
                                Take a look at the source on the "Selection" tab example to see how.
                            </nui-message>
                        </ng-container>
                    </nui-expander>
                </li>
                <li *ngIf="type == componentType.list">
                    <nui-expander [open]="false" header="radio">
                        <p>Enables single-selection with deselection not allowed.</p>
                    </nui-expander>
                </li>
                <li *ngIf="type == componentType.list">
                    <nui-expander [open]="false" header="single">
                        <p>Enables single-selection with no radio buttons and deselection allowed.</p>
                    </nui-expander>
                </li>
                <li *ngIf="type == componentType.list">
                    <nui-expander [open]="false" header="singleWithRequiredSelection">
                        <p>Enables single-selection with no radio buttons and deselection not allowed.</p>
                    </nui-expander>
                </li>
                <li *ngIf="type == componentType.list">
                    <nui-expander [open]="false" header="radioWithNonRequiredSelection">
                        <p>Enables single-selection with deselection allowed.</p>
                    </nui-expander>
                </li>
            </ul>
        </ng-template>
    </ng-container>

    <ng-container *ngSwitchCase="'pagingMode'">
        <p>
            This string option allows you to select the paging mode of the data presentation. Default is
            <code>virtualScroll</code>. The values currently supported for this option are:
        </p>
        <ul>
            <li>
                <nui-expander [open]="false" header="virtualScroll">
                    <p>
                        This setting allows us to use
                        <a href="https://material.angular.io/cdk/scrolling/overview">CDK Virtual Scroll</a>
                        by setting <code>pagingMode</code> to <code>virtualScroll</code>.
                    </p>
                    <ng-container *ngTemplateOutlet="helpRenderer;context:{tpl: pagingModeVSTpl, types: [componentType.list, componentType.table]}"></ng-container>
                    <ng-template #pagingModeVSTpl let-type=type>
                        <ng-container *ngIf="type == componentType.list">
                            <p>
                                The <code>nui-repeat</code> used inside this schematic allows you to manage the
                                virtual viewport by exposing its <code>{{getRepeatPropKey('viewportRef')}}</code>
                                property which is an instance of
                                <code><a href="https://material.angular.io/cdk/scrolling/api#CdkVirtualScrollViewport">CdkVirtualScrollViewport</a></code>.
                                The example below uses Nova's
                                <code><a href="/injectables/VirtualViewportManager.html">VirtualViewportManager</a></code>
                                to handle the viewport management duties via the
                                <code>{{getRepeatPropKey('viewportRef')}}</code> property.
                            </p>
                        </ng-container>
                        <ng-container *ngIf="type == componentType.table">
                            The <code>nui-table</code> used inside this schematic API is using
                            <a href="../directives/TableVirtualScrollLinearDirective.html#info">nui table virtual scroll directive</a>. It makes it possible to
                            load items in chunks. The amount of items loaded per fetch can be configured by setting the <code>range</code> variable.

                            <nui-message [allowDismiss]=false type="warning">
                                The following examples use custom Nova <a href="../directives/TableVirtualScrollLinearDirective.html#info">TableVirtualScrollLinearDirective</a> to perform scrolling
                                based on scrolling indexes within the virtual scroll viewport. Customers are free to create their own directive and\or scrolling strategy if they want
                                custom behavior.
                            </nui-message>
                            <nui-message [allowDismiss]=false type="warning">
                                There are some known <strong>technical limitations</strong>:<br />
                                <ol>
                                    <li>
                                        Data for the table should be provided in a DataSource service
                                    </li>
                                    <li>
                                        Each datasource should have a page counter, to enable items prefetching (in case the viewport size is larger that the chosen items per page selected)
                                    </li>
                                    <li>
                                        <a href="https://github.com/angular/components/issues/10113">Angular doesn't subport virtual scrolling over a list of items whose size is
                                            not known and needs to be measured</a>
                                    </li>
                                    <li>
                                        When CDK Viewport is used in context of non-visible dom elements (eg: Tabs, Accordion) virtual scroll will not work properly.
                                        The solution is not do initiate the viewport until it is visible using *ngIf, *ngSwitch.
                                    </li>
                                </ol>
                            </nui-message>
                        </ng-container>

                        <ng-container *ngIf="type == componentType.table">
                            <p>
                                To make the scrolling working with <code>nui-table</code> start with declaring the following variables:<br /><br />
                            </p>
                            <nui-example-code language="typescript">{{tableScrollingSetup.vars}}</nui-example-code><br />

                            <p>
                                Import <a href="../injectables/VirtualViewportManager.html" target="_blank">VirtualViewportManager</a>
                                (provides a mechanism for sequencing the rendered range stream emitted from the CDK Viewport into distinct page ranges):<br />
                            </p>
                            <nui-example-code language="typescript">{{tableScrollingSetup.viewportManagerImport}}</nui-example-code><br />
                            <p>
                                Provide VirtualViewportManager on a component level providers:<br />
                            </p>
                            <nui-example-code language="typescript">{{tableScrollingSetup.provideViewport}}</nui-example-code><br />

                            <p>
                                Inject VirtualViewportManager type in the constructor:<br />
                            </p>
                            <nui-example-code language="typescript">{{tableScrollingSetup.injectViewport}}</nui-example-code><br />

                            <p>
                                Use the Angular ViewChild decorator to get a reference to the scrolling viewport (CdkVirtualScrollViewport):<br />
                            </p>
                            <nui-example-code language="typescript">{{tableScrollingSetup.viewChildren}}</nui-example-code><br />

                            <p>
                                Register the virtual scroll filter on dataSource:
                            </p>
                            <nui-example-code language="typescript">{{tableScrollingSetup.registerScroll}}</nui-example-code><br />

                            <p>
                                Optionally, subscribe to the <code>busy</code> state changes:
                            </p>
                            <nui-example-code language="typescript">{{tableScrollingSetup.oninitSubscribeBusy}}</nui-example-code><br />
                            <p>
                                Start setting up the <code>ngAfterViewInit()</code> lifecycle hook:<br />
                            </p>
                            <nui-example-code language="typescript">{{tableScrollingSetup.ngAfterViewInitStart}}</nui-example-code><br />

                            Setting up the viewportManager listener and dataSource handler in the <code>ngAfterViewInit</code>:
                            <ol>
                                <li>Use the <strong>setViewport</strong> method to initialize <code>VirtualViewportManager</code>.</li>
                                <li>Chain the <strong>observeNextPage$</strong> method with the required parameters (<a href="../interfaces/IVirtualPageConfig.html">IVirtualPageConfig)</a>.</li>
                                <li>
                                    <b><i>Optional</i></b> You may like to ignore <code>VirtualViewportManager</code> emissions when the <code>totalItems</code> number is reached.
                                    To do this, you can use the RxJS <code>filter</code> operator as in example.<br />
                                    <b>Note:</b> <code>VirtualViewportManager</code> has its own mechanism of stopping when the length of the last received page is less than the page size requested. <br />
                                    In the example, we use the <code>filter</code> operator to avoid making the additional requests when the dataset's last page has enough data.
                                </li>
                                <li>Finally, call <code>datasource.applyFilters()</code> to trigger fetching of the data.</li>
                                <li>
                                    To avoid having two listeners (the next page observer and the data source's outputsSubject), we can combine them together into one stream <br />
                                    with the RxJS <code>switchMap</code> operator. In the example, we map to an inner subscription which contains all new data related operations: <br />
                                    <code>totalItems</code> update, assigning new data, and triggering the change detector. <br />
                                    <b>Alternative</b>: You can subscribe to the <code>this.dataSource.outputsSubject</code>code> in the ngOnInit method using the same RxJS pipe operators.
                                </li>
                            </ol>
                            <nui-example-code language="typescript">{{tableScrollingSetup.ngAfterViewInitViewport}}</nui-example-code><br />
                        </ng-container>
                    </ng-template>
                    <p>
                        Although the generated code of the schematic already takes care of basic setup
                        steps, please make sure while customizing this feature for your own use case to
                        do the following on the component:
                    </p>
                    <ol>
                        <li *ngIf="for(componentType.list)">
                            <strong>For <code>list</code>'s only</strong>: set the <code>itemSize</code> component input to a valid value. It's
                            mandatory to have this input set as there is a technical limitation on the
                            Angular side. If the input is omitted, you'll see this error message in the
                            console output:
                            <mark>
                                "ERROR: To use virtual scroll feature please set correct value to the
                                'itemSize' input!"
                            </mark>
                        </li>
                        <li>
                            Set the <code>height</code> of the component element (either through a
                            css/less file or inline in the ng-container). This sets the viewport for the
                            virtual scroll. If this action is omitted, the viewport will have a height of
                            <code>0px</code> and no content will be visible on the page.
                        </li>
                    </ol>

                    <nui-message [allowDismiss]="false" type="warning">
                        <ol>
                            <li>
                                If the user filters the results in some way, say with a search box, make sure to
                                reset progress on the VirtualViewportManager before applying the filters.
                            </li>
                            <li>
                                Due to a <a href="https://github.com/angular/components/issues/13981" target="_blank">known
                                CDK issue</a>,
                                make sure that the <code>nui-repeat</code> component hosting the virtual scroll is
                                visible
                                in order for the virtual scroll functionality to work properly.
                            </li>
                        </ol>
                    </nui-message>
                </nui-expander>
            </li>
            <li>
                <nui-expander [open]="false" header="pagination">
                    Data is displayed using standard pagination with a <code>nui-paginator</code> component.
                    <p>
                        To enable pagination, do the following:
                    </p>
                    <ol>
                        <li>
                            Provide a service that performs filtering (pagination is considered to be a form of
                            filtering in Nova). There is a default service, <a target="_blank" href="../injectables/ClientSideDataSource.html">
                            <code>ClientSideDataSource</code></a>, which provides default methods for working with
                            filters. In case you need something special (such as filtering on a back-end or more complex
                            sorting capability), you may extend this service and override its methods.
                        </li>
                        <li>
                            In your component's constructor, provide an initial dataset via the <code>setData</code>
                            method
                            of
                            <a target="_blank" href="../injectables/ClientSideDataSource.html">
                                <code>ClientSideDataSource</code></a>.
                        </li>
                        <li>
                            Get the paginator component via <code>@ViewChild</code>.
                        </li>
                        <li>
                            In your component's <code>ngAfterViewInit</code>, pass the paginator to the
                            <code>componentTree</code>
                            property of <code>ClientSideDataSource</code>. Then, invoke the
                            <code>applyFilters</code>
                            method of
                            <a target="_blank" href="../injectables/ClientSideDataSource.html">
                                <code>ClientSideDataSource</code></a>. And, lastly, subscribe to
                            <code>outputsSubject</code> on
                            <a target="_blank" href="../injectables/ClientSideDataSource.html">
                                <code>ClientSideDataSource</code></a> which will return an <a target="_blank"
                                                                                                  href="../interfaces/INovaFilteringOutputs.html">
                            <code>INovaFilteringOutputs</code></a> object after each change in pagination.
                        </li>
                        <li>
                            In the <code>outputsSubject</code> subscription handler, overwrite your
                            <code>dataSource</code>
                            with the
                            <code>itemsSource</code> you receive and pass the number of pages to the paginator's
                            <code>total</code> input.
                        </li>
                        <li>
                            Bind to the paginator's <code>pagerAction</code> output, and invoke the
                            <code>applyFilters</code> method of
                            <a target="_blank" href="../injectables/ClientSideDataSource.html"><code>ClientSideDataSource</code></a>
                            in the output handler.
                        </li>
                        <li>
                            Unsubscribe from the <code>outputsSubject</code> in your component's
                            <code>ngOnDestroy</code>
                            method.
                        </li>
                    </ol>
                </nui-expander>
            </li>
            <li>
                <nui-expander [open]="false" header="none">
                    All data is displayed at once.
                </nui-expander>
            </li>
        </ul>
    </ng-container>

    <ng-container *ngSwitchCase="'dataSource'">
        <p>
            This string option allows you to select the way data is retrieved for displaying in the {{forComponent ? forComponent : "component"}}.
            Default is <code>serverSide</code>. The values currently supported for this option are:
        </p>
        <nui-expander [open]="false" header="serverSide">
            The generated data source will retrieve data remotely from a server side API, usually achieved by extending
            the
            <a target="_blank" href="../injectables/DataSourceService.html"><code>DataSourceService</code></a> class.
            <nui-message [allowDismiss]="false" type="info">
                When this option is chosen, the schematic automatically generates a loading indicator
                (<code>nui-busy</code>) which is displayed as an overlay on the list during data
                retrieval.
            </nui-message>
        </nui-expander>
        <nui-expander [open]="false" header="custom">
            <p>No data source will be generated, allowing you to create one from scratch.</p>
        </nui-expander>
        <nui-expander [open]="false" header="clientSide">
            Generated data source will retrieve data locally from a client side source, usually via the
            <a target="_blank" href="../injectables/ClientSideDataSource.html"><code>ClientSideDataSource</code></a>
            class.
        </nui-expander>
        <nui-expander [open]="false" header="none">
            No data source will be generated and no data source related features
            such as sorting or search will be added to the generated code.
        </nui-expander>
        <div>
            <p>
                For additional information on how the data source setup is done please consult the paragraphs below:
            </p>
            <nui-expander [open]="false" header="DataSource Setup">
                <p>Both local and remote setup are feasible for custom data sources, while the remote setup is feasible
                    for
                    the <code>serverSide</code> option.</p>
                <nui-expander [open]="false" header="Remote DataSource Setup">
                    <div>
                        <p>
                            To make component work with remote backend, it's advised to use the Nova
                            <code>DataSourceService</code>
                            which can be imported from
                            <code>"@nova-ui/bits"</code>.
                        </p>
                        <p>Create the <code>@Injectable</code> class that extends the data source service mentioned
                            above.
                        </p>
                        <nui-example-code language="typescript">{{dataSourceSetup.extendDS}}</nui-example-code>
                        <br/>

                        <p>
                            Define the following fields to work with the data source.<br/>
                            <mark><sup><strong>Hint!</strong></sup> The list below is a required minimum. Feel free to
                                define other fields required to work with your API.
                            </mark>
                        </p>
                        <br/>
                        <code><b>url</b></code> - This is where you store your API url. <br/>
                        <code><b>cache</b></code> - This is where you store the cached list data. Because we fetch the
                        data
                        in chunks, every time a user fetches a new chunk of data
                        it is appended to that array immediately, and then the updated array is sent to the list.<br/>
                        <code><sup>(Optional)</sup><b>busy</b></code> - This sets the busy state. The state is
                        considered
                        busy only when the data is being fetched, and it's used to display loading indicator
                        components on the view while the data is being fetched. This is optional.
                        <mark>Consult with your UX team about using busy state and busy components in your list</mark>
                        .
                        <nui-example-code language="typescript">{{dataSourceSetup.defineFields}}</nui-example-code>
                        <br/>

                        <p>
                            Create a method that will fetch the data and perhaps convert the response to an expected
                            format.
                            It should have two parameters, <code>start</code>
                            and <code>end</code>, which are the current values of the scrolling indices within the
                            scrolling
                            viewport. The calculation <code>end - start</code> will give you the number
                            of items to fetch. If your API supports returning data by page, the <code>page</code>
                            variable
                            will be useful in that case, but if not, use the <code>end</code> index
                            as the starting point for the next chunk of data.<br/>
                            Next, prepare the URI to be fetched. It can, and probably will, vary by API implementation.
                            Your
                            goal here is to return the requested number of items.
                        </p>
                        <nui-example-code language="typescript">{{fetch}}</nui-example-code>
                        <br/>

                        <p>
                            Afterwards, when you get the data back as a response, convert the returned dataset into the
                            structure expected by the
                            component. The received data will be concatenated with <code>this.cache</code>,
                            so
                            the dataset must be in the format expected by the
                            list's <code>dataSource</code> input in order to render the items correctly.
                        </p>
                        <nui-example-code language="typescript">{{dataSourceSetup.getData}}</nui-example-code>
                        <br/>

                        <p>
                            The next step will be to implement the <code>getFilteredData</code> method of the <code>DataSourceService</code>.
                            This method is called whenever the
                            <code>applyFilters</code> method of current data source is called in the code, so this is
                            where
                            data operations will be triggered.
                            Optionally, notify the <code>busy</code> observable to toggle the busy state to "on". Then,
                            retrieve the <code>virtualScroll</code> from the available filters
                            passed into the method as an argument. The <code>virtualScroll</code> filter is registered
                            with
                            the data source farther down in the code listing of the list implementation.<br/><br/>

                            From the <code>virtualScroll</code> filter you can retrieve the <code>start</code> and
                            <code>end</code> indices for the scrolling viewport.
                            Use them to fetch to correct amount of data. Then, update the cache with the items you just
                            got
                            from the server, and return the data in the format that would
                            contain AT LEAST the total number of items the API is able to return and the list's cached
                            data.
                        </p>
                        <nui-example-code language="typescript">{{dataSourceSetup.getFilteredData}}</nui-example-code>
                        <br/>

                        <p>All data source preparation steps are finished at this point.</p>
                    </div>
                </nui-expander>
                <nui-expander [open]="false" header="Local DataSource Setup">
                    <p>
                        To make the component work with a local API it's advised
                        to extend <a target="_blank" href="../injectables/ClientSideDataSource.html"><code>ClientSideDataSource</code></a>
                        which can be imported from <code>"@nova-ui/bits"</code>.
                    </p>
                </nui-expander>
            </nui-expander>
        </div>
    </ng-container>

    <ng-container *ngSwitchCase="'enableSearch'">
        <p>
            This boolean option allows you to enable/disable search functionality. Default is
            <code>true</code>.
        </p>
        <p>
            To subscribe to the search events, use search's <code>onSearch</code> or <code>inputChange</code>
            (and, if needed, <code>onSearchCancel</code>) hooks to invoke the <code>applyFilters</code>
            method of the <a target="_blank" href="../injectables/DataSourceService.html"><code>DataSourceService</code></a>
            class
            in order to perform the actual search.
        </p>
        <nui-message [allowDismiss]="false" type="warning">
            <ol>
                <li>
                    For remote data sources, which usually extend or use directly <a target="_blank" href="../injectables/ServerSideDataSource.html">
                    <code>ServerSideDataSource</code></a>, if you want searches to be performed as the user types, it's advised to
                    add a debounce to the filtering to avoid stressing out the backend API by using
                    <code>pipe(debounceTime(Integer_Value))</code> between search subscriptions.
                </li>
                <li>
                    For local data sources, which usually extend or use directly <a target="_blank" href="../injectables/ClientSideDataSource.html">
                    <code>ClientSideDataSource</code></a>, you can use the <code>setSearchProperties</code> method of
                    <a target="_blank" href="../injectables/ClientSideDataSource.html"><code>ClientSideDataSource</code></a>
                    to specify which columns the search should apply to; if not set, the search will be performed on all columns.
                </li>
            </ol>
        </nui-message>
    </ng-container>

    <ng-container *ngSwitchCase="'enableSort'">
        <p>
            This boolean option allows you to enable/disable sorting functionality. Default is
            <code>true</code>.
        </p>
        <ng-container *ngIf="for(componentType.table)">
            <p>To use sorting in a table you need to:</p>
            <ol>
                <li>Set <code>[sortable]="true"</code> on <code>nui-table</code>.</li>
                <li>Get table component via <code>@ViewChild</code>.</li>
                <li>Set up the filtering component tree. To get table filtering components use <code>getFilterComponents()</code>
                    function of table component.
                    This will give filtering mechanism an ability to receive data for sorting at the moment you'll call
                    <code>applyFilters</code> method of <a target="_blank"
                                                           href="../injectables/ClientSideDataSource.html"><code>ClientSideDataSource</code></a>.
                </li>
                <li>Set <code>[isColumnSortingDisabled]="true"</code> on the table-header-cell to prevent table from
                    sorting by this property.
                </li>
                <li>Subscribe to <code>outputsSubject</code> on <a target="_blank"
                                                                   href="../injectables/ClientSideDataSource.html">
                    <code>ClientSideDataSource</code></a> which will return you <a target="_blank"
                                                                                       href="../interfaces/INovaFilteringOutputs.html">
                    <code>INovaFilteringOutputs</code></a> object after each change of sorting.
                </li>
                <li>In the <code>outputsSubject</code> subscription handler, overwrite your <code>dataSource</code> with
                    the <code>itemsSource</code> you receive.
                </li>
                <li>On <code>(sortOrderChanged)</code> event call <code>applyFilters</code> method of
                    <a target="_blank" href="../injectables/ClientSideDataSource.html"><code>ClientSideDataSource</code></a>.
                    <code>(sortOrderChanged)</code> event will emit you <a target="_blank"
                                                                           href="../interfaces/ISortedItem.html">
                        <code>ISortedItem</code></a> object.
                </li>
                <li>Unsubscribe from the <code>outputsSubject</code> in your component's <code>ngOnDestroy</code>
                    method.
                </li>
            </ol>
            <nui-message [allowDismiss]="false" type="info">
                <ul>
                    <li>
                        If you need to apply a more complicated sorting algorithm, you can extend
                        <code>ClientSideDataSource</code> and override its sorting methods.
                    </li>
                    <li>
                        If you need to sort some column by default (or programmatically), you can do that by passing <a
                        target="_blank" href="../interfaces/ISortedItem.html">
                        <code>ISortedItem</code></a> to <code>[sortingColumn]</code> input of the table.
                    </li>
                </ul>
            </nui-message>
        </ng-container>
    </ng-container>

    <ng-container *ngSwitchCase="'chips'">
        <p>
            This boolean option allows you to enable/disable chips functionality. Default is
            <code>true</code>.
        </p>
    </ng-container>

    <ng-container *ngSwitchDefault>
        <ng-content></ng-content>
    </ng-container>
</div>

<ng-template #helpRenderer let-types=types let-tpl=tpl>
    <ng-container [ngSwitch]="forComponent ? forComponent : 'shared'">
        <ng-container *ngSwitchDefault>
            <ng-container *ngTemplateOutlet="tpl;context:{type: forComponent}"></ng-container>
        </ng-container>
        <ng-container *ngSwitchCase="'shared'">
            <ul>
                <li *ngFor="let type of types">
                    <nui-expander [open]="false" header="{{type}}">
                        <ng-container *ngTemplateOutlet="tpl;context:{type: type}"></ng-container>
                    </nui-expander>
                </li>
            </ul>
        </ng-container>
    </ng-container>
</ng-template>
